---
title: "Holger Russ scRNA-Seq analysis figures"
author: "Kent Riemondy RBI"
date: "`r Sys.Date()`"
bibliography: "/Users/kriemo/Projects/russ/docs/bibliography.bib"
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    fig_caption: yes
    fig_retina: 1 
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(cache.lazy = FALSE)
```


```{r libs, message=FALSE, warning=FALSE, echo=FALSE}
source("../../R/globals.R")
data_dir <- "~/Projects/10x_data/runs/20180524_russ/results"
tcols <- rev(brewer.pal(11, "RdGy")[c(1:5, 7)])[c(1,6)]

bcells <- readRDS("sobj.rds")
```

```{r examine_umi_and_ngenes, fig.width = 10, fig.height = 8, warning = F}

ids <- colnames(bcells@raw.data)
ids <- str_split(ids, "_[ATCG]{10}", simplify = T) %>% .[, 1]
ids <- data.frame(cell = colnames(bcells@raw.data),
                  expt = ids)
summary_dat <- data_frame(cell = colnames(bcells@raw.data), 
                          nUMI = colSums(as.matrix(bcells@raw.data)),
                          nGene = colSums(as.matrix(bcells@raw.data) > 0)) %>% 
  left_join(., ids, by = "cell")

summary_dat <- summary_dat %>% 
  group_by(expt) %>% 
  dplyr::arrange(desc(nUMI))

n_cells <- summary_dat %>%  
  group_by(expt) %>%  
  summarize(n_cells = n(),
            median_UMI = median(nUMI),
            median_Genes = median(nGene))

knitr::kable(n_cells,
             caption = "Number of cells prior to filtering and summary statistics")

a <- ggplot(summary_dat, aes(expt, nUMI)) +
  geom_violin(aes(fill = expt)) +
  scale_fill_brewer(palette = "Paired") +
  ylab("Number of UMIs (Log10)") +
  theme(axis.text.x = element_blank())

b <- ggplot(summary_dat, aes(expt, nGene)) +
    geom_violin(aes(fill = expt)) +
  scale_fill_brewer(palette = "Paired") +
  ylab("Number of Genes (at least 1 UMI) Log10") +
  theme(axis.text.x = element_blank())
plot_grid(a, b, ncol = 1)
```

Overall the numbers of UMIs and genes detected are good and in the expected range for single cell data. 


## Mitochondrial Reads {.tabset .tabset-fade}

The percentage of reads aligning to mitochondria is often an indicator of cell quality. Cells that have lysed prior to capture preferentially retain mitochondial RNA, but lose cellular cytoplasmic mRNA. As shown below there is a strong negative correlation with the number of UMIs and the proportion of reads aligning to mitochondria. Cells with less than 20% mitochondrial reads will be retained for further analysis.

```{r QC}
mito.genes <- grep("^MT-", rownames(bcells@raw.data), value = T)
proportion.mito <- Matrix::colSums(bcells@raw.data[mito.genes, ]) /
  Matrix::colSums(bcells@raw.data)

unfiltered <- bcells@meta.data %>% 
  tibble::rownames_to_column("cell") %>% 
  left_join(ids, by = c("cell", "expt")) %>% 
  as_data_frame()

unfiltered <- data_frame(cell = names(proportion.mito), 
                         proportion.mito = proportion.mito) %>% 
  left_join(., ids, by = "cell") %>% 
  left_join(., summary_dat)

ggplot(unfiltered, aes(expt,
                       proportion.mito)) +
  geom_jitter(size = 0.25) +
  geom_violin(aes(fill = expt), alpha = 0.66) +
  scale_fill_brewer(palette = "Paired") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    axis.title.x = element_blank()
  )
```

### All Samples

```{r sample_ids}
ggplot(unfiltered, 
       aes(nUMI, proportion.mito)) +
  geom_point(aes(color = expt)) +
  scale_color_brewer(palette = "Paired")
```

```{r, results ='asis'}

sample_names <- as.character(unique(bcells@meta.data$expt))
per_sample <- map(sample_names, ~filter(unfiltered, 
                                        expt == .x))

# generate tab with individual plot programmatically 
# see https://stackoverflow.com/questions/43752095/programmatically-insert-header-and-plot-in-same-code-chunk-with-r-markdown-using?noredirect=1&lq=1

for(i in seq_along(per_sample)){
  .col <- brewer.pal(10, "Paired")[i]
  cat('\n### ', sample_names[i], '\n')
  p <- ggplot(per_sample[[i]], aes(nUMI, proportion.mito)) +
        geom_point(aes(color = expt)) +
        scale_color_manual(values = .col)
  print(p)
  cat('\n')
}
```

Cells with low UMIs tend to have a higher percentage of mitochondrial reads, suggesting that these cells have lysed prematurely. However, overall a large proportion of cells are retained for further analysis after removing cells with > 20% UMIs derived from mitochondiral transcripts. 

## Filtered Data {.tabset .tabset-fade}

After filtering the distribution of UMIs, Genes, and Proportion of mitochondrial reads are shown as selectable tabs. 



```{r ngenes_filter}

cell_counts <- function(seurat_object){
  #returns tbl_df with number of cells per sample type in seurat object
  map_df(levels(seurat_object@ident), 
         ~data_frame(sample = .x, 
                     n_cells = length(WhichCells(seurat_object, ident = .x))))
}

knitr::kable(cell_counts(SetAllIdent(bcells, "expt")),
             caption = "Number of cells passing an additional filter requiring less than 20% mitochondrial reads and at least 250 genes detected, and UMI < 50000")
```

### Number of Genes
```{r ngenes_post_filter, fig.height = 8}
VlnPlot(bcells, "nGene", 
        cols.use = brewer.pal(10, "Paired"),
        group.by = "expt",
        x.lab.rot = T)
```

### Number of UMIs
```{r, fig.height = 8}
VlnPlot(bcells, "nUMI", 
        cols.use = brewer.pal(10, "Paired"),
        group.by = "expt",
        x.lab.rot = T)
```

### Proportion of Mitochondria
```{r, fig.height = 8}
VlnPlot(bcells, "proportion.mito", 
        cols.use = brewer.pal(10, "Paired"),
        group.by = "expt",
        x.lab.rot = T)

```

### GFP/LUC counts
```{r read_in_count}

VlnPlot(bcells, 
        c("egfp", "luc-firefly"),
        cols.use = brewer.pal(n = 10, "Paired"), 
        group.by = "expt",
        x.lab.rot = T,
        y.log = T)


```



## Preprocess the data for PCA, TSNE, and Clustering 
  The raw UMI count matrix will next be preprocessed for downstream clustering and visualization
  
### Normalize the data
  First the UMI count data will be normalized. The normalization strategy implements a pooled normalization approach to improve standard normalization [@Lun2016-fe]. Different cell populations can have large gene abundance and RNA content differences, which is problematic for simple library-size based normalization (i.e # of UMIs per gene / total UMIs per cell). This pooling approach find clusters cells to identify the cell popuations, then computes per cell normalization factors. The R package `scran`[http://bioconductor.org/packages/release/bioc/html/scran.html] implements this normalization method. 


### Identify variable genes

  The normalized UMI count matrix contains `r  length(rownames(bcells@data))` genes and `r length(colnames(bcells@data))` cells. Most of these genes have very low expression or very low variance across all of the cells in the dataset. These genes are therefore very uninformative for classifying different cell types. In this next step the set of variable genes useful for classification will be identified, and used for downstream PCA, TSNE, and classification purposes. 
  
  Variable genes will be selected by examining a plot of the average expression across all cells on the x axis to the dispersion across all genes. Highly variable genes will have non-zero dispersion. The dispersion is defined by the variance / mean. 


### Control for noise
  Single-cell data is often noisy, and it is difficult to compare cells with very high UMIs to very low UMIs. For classification we do not want to bias our clusters based on nuisance variables such as UMI count or proportion of mitochondria. To help mitigate bias in our clustering a regression model is fit to predict gene expression based on nuisance variables. The residuals from this fit are then scaled and centered (i.e. turned into z-scores) for classification purposes. The scaled regressed data is not used for differential expression, but used only for classifcation, TSNE visualization, and pseudotime analysis. 


### Calculate Principal Components

  PCA will now be performed on processed data using only the set of variable genes defined above. PCA will generate a set of new vectors that describe the variablity in the data. A subset of these principal components will be selected to be used as input data for TSNE visualization. Selecting the proper number of components is informed by examining the amount of variance captured in each PC. Shown below is a plot of variance captured in each PC. At a certain point, additional PCs capture little additional varaince, and therefore are uninformative for classification. For this dataset 17 PCs will be used for classification.
  
```{r PCA_calc, results='hide'}

PCElbowPlot(bcells)
```

### PCA Plots {.tabset .tabsetfade}
  Shown in the tabs are 2 dimensional plots showing different principal components. Overall the data looks good as there is quite alot of structure to the data and many consisent populations that match the sample types are observed.
  
```{r pc_plots, results ='asis'}
pcs <- list(
  c(1, 2),
  c(1, 3),
  c(1, 4),
  c(2, 3),
  c(2, 4),
  c(3, 4)
)


for(i in seq_along(pcs)){
  cat('\n#### ', 'PC', pcs[[i]][1], ' vs PC', pcs[[i]][2], '\n', sep = "")
  PCAPlot(bcells, 
               pcs[[i]][1], 
               pcs[[i]][2], 
               cols.use = brewer.pal(10, "Paired"), 
        group.by = "expt")
  #print(p)
  cat('\n')
}
```

### Run TSNE {.tabset .tabsetfade}
  [TSNE](https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding) is a non-linear method that is used to visualize the relationships between cells in two dimensions. TSNE will use the first 17 PCs calculated above to project cells into 2D space for visualization. The TSNE plot will be used for visualization purposes, but note that clustering will be performed using the 17 PCs rather than just the 2 dimensions of the TSNE. The perplexity setting of the TSNE analysis can impact the spacing of points and for this data a default setting of 30 (perplexity = 30) works well. Interpreting a tSNE plot can be somewhat challenging, a group from google produced a nice [report](https://distill.pub/2016/misread-tsne/) that discusses some of the potential issues with tSNE.
  

  Shown below is a TSNE projection of the single cell data, with each cell colored by the sample type. The TSNE project shows a very consistent pattern between the two experiments. 
  
#### Sample Names

```{r plot_TSNE, fig.width = 10, fig.height = 10}
TSNEPlot(bcells, 
         colors.use = brewer.pal(n = 10, "Paired"), 
         group.by = "expt")
```


#### Genes Detected
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcells, "nGene", no.legend = F, cols.use = tcols)
```

#### UMIs Detected
```{r, fig.width = 10, fig.height = 10 }

FeaturePlot(bcells, "nUMI", no.legend = F, cols.use = tcols)

```

#### Proportion Mito
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcells, "proportion.mito", no.legend = F, cols.use = tcols)
```

#### GFP
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcells, c("egfp"), no.legend = F, cols.use = tcols)
```

#### Luc
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcells, c("luc-firefly"), no.legend = F, cols.use = tcols)
```

#### INS 
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcells, c("INS"), no.legend = F, cols.use = tcols)
```

#### by experiment

```{r, fig.width = 20, fig.height= 6}
bcells <- SetAllIdent(bcells, "expt")
sample_names <- unique(bcells@meta.data$expt)
ord <- levels(bcells@meta.data$expt)

cell_ids <- map(ord, ~bcells@cell.names[bcells@meta.data$expt == .x])
names(cell_ids) <- ord
.cols <- brewer.pal(n = 10, "Paired")[1:length(sample_names)]

p <- map2(cell_ids,
         .cols,
         ~TSNEPlot(bcells, 
                   do.label = F, 
                   pt.size = 0.5, 
                   cells.use = .x, 
                   do.return = T, 
                   colors.use = .y,
                   label.size = 5))

p[[3]] <- TSNEPlot(bcells, 
                   do.label = F, 
                   pt.size = 0.5, 
                   do.return = T, 
                   colors.use  = .cols,
                   label.size = 5)


plt <- plot_grid(plotlist = p, nrow = 1, 
                 align = "hv")

plt

save_plot("per_expt_tsne.pdf", plt, ncol = 3, nrow = 1)
```


## Clusters

```{r }
bcells <- SetAllIdent(bcells, "res.0.3") 

TSNEPlot(bcells, 
                pt.size = 0.5,
                do.label = T,
                label.size = 10,
                do.return = T,
                no.legend = T)
```


## Marker gene expression for each cluster {.tabset .tabset-fade}

  Plotted below are a set of known marker genes that help to identify each cell population. 

Click on the tabs to view other markers

```{r marker genes, fig.width = 10, fig.height= 10}

control_markers <- c(
  "CD9",
  "ST8SIA1",
  "INS",
  "NPY",
  "KCNE4",
  "HCN1",
  "DAB1",
  "ST8SIA1",
  "HCN4",
  "NEUROD1",
  "SCGB2A1",
  "KLHL1",
  "SLC44A4",
  "GCG", # alpha cells glucagon
  "IAPP", # beta cells amylin,
  "SST", # delta cells Somatostatin
  "PPY", # PP cells  (gamma cells or F cells) pancreatic polypeptide
  "GHRL" # Epsilon cells
)
```

### Various
```{r, fig.width=20, fig.height=20}
FeaturePlot(bcells, control_markers, 
            pt.size = 0.50, cols.use = tcols)

```

## Top genes per cell type {.tabset .tabset-fade}
  Plotted are the abundances of the top marker genes detected per identified cell type (red is high, grey is low) projected onto the TSNE map. 
  
```{r genes_enriched_per_cluster}

bcells_markers <- suppressMessages(read_tsv("res0.3_markers.txt"))

bcells_markers %>% 
  group_by(cluster) %>% 
  top_n(25, avg_logFC) -> top25

top_genenames <- split(top25, 
                        top25$cluster) %>% 
  map(., ~.x[1:4, ]$gene)

```

```{r tsnes_per_cluster, fig.width = 10, fig.height= 10, results = "asis"}

for(i in seq_along(top_genenames)){
  cat('\n### ', names(top_genenames)[i], '\n', sep = "")
  FeaturePlot(bcells, top_genenames[[i]], pt.size = 0.5, cols.use = tcols)
  cat('\n')
}
```

## Distribution of cells per cell type


```{r cluster_distribution}
cluster_ids <- bcells@meta.data$res.0.3
cell_ids <- bcells@cell.names
expt <- bcells@meta.data$expt

cluster_summary <- data_frame(id = cell_ids, expt = expt, cluster = cluster_ids)
cluster_summary <- group_by(cluster_summary, expt, cluster) %>% summarize(cells = n())

ggplot(cluster_summary, aes(cluster, cells)) +
  ylab("Number of Cells") +
  scale_fill_brewer(palette = "Paired") +
  geom_bar(stat = "identity", 
           aes(fill = expt), position = "dodge") 
```

```{r cluster}
bcells <- SetAllIdent(bcells, "res.0.3") 

TSNEPlot(bcells, 
                pt.size = 0.5,
                do.label = T,
                label.size = 10,
                do.return = T,
                no.legend = T)


  
```


## Compare to other datasets

```{r dl_data}
dir.create(file.path(project_dir, "docs", "extdata"))
dl_dir <- file.path(project_dir, "docs", "extdata")
```


http://dx.doi.org/10.1016/j.cmet.2016.08.018
```{r xin_2016}
dl_url <- "https://scrnaseq-public-datasets.s3.amazonaws.com/scater-objects/xin.rds"
fn <- file.path(dl_dir, "xin.rds")
if(!file.exists(fn)){
  download.file(dl_url, fn)
}

xin_sce <- readRDS(fn)
```

http://dx.doi.org/10.1016/j.cmet.2016.08.020

```{r seger_2016}
dl_url <- "https://scrnaseq-public-datasets.s3.amazonaws.com/scater-objects/segerstolpe.rds"
fn <- file.path(dl_dir, "segerstolpe.rds")
if(!file.exists(fn)){
  download.file(dl_url, fn)
}

seg_sce <- readRDS(fn)
```


http://dx.doi.org/10.1016/j.cels.2016.09.002
```{r muraro_2016}
dl_url <- "https://scrnaseq-public-datasets.s3.amazonaws.com/scater-objects/muraro.rds"
fn <- file.path(dl_dir, "muraro.rds")
if(!file.exists(fn)){
  download.file(dl_url, fn)
}

muraro_sce <- readRDS(fn)
```

http://dx.doi.org/10.1016/j.cels.2016.08.011
```{r baron_2016}
dl_url <- "https://scrnaseq-public-datasets.s3.amazonaws.com/scater-objects/baron-human.rds"
fn <- file.path(dl_dir, "baron.rds")
if(!file.exists(fn)){
  download.file(dl_url, fn)
}

baron_sce <- readRDS(fn)
```

####baron dataset

try to co-cluster the datasets

```{r}

#find shared gene_names

shared_genes <- intersect(rownames(bcells@raw.data),
          rowData(baron_sce)$feature_symbol)

sc_mat <- assay(baron_sce, "counts")[shared_genes, ]
sc_mat <- as(sc_mat, "sparseMatrix")

combined_mat <- cbind(bcells@raw.data[shared_genes, ],
                      sc_mat)

sobj <- CreateSeuratObject(combined_mat, 
                   min.cells = 5,
                   min.genes = 200)
rm(combined_mat)
rm(sc_mat)
sobj <- NormalizeData(sobj)
sobj <- FindVariableGenes(sobj, do.plot = T, y.cutoff = 0.125)
sobj <- ScaleData(sobj, genes.use = sobj@var.genes, do.par = TRUE, num.cores = 4)
sobj <- RunPCA(sobj, pc.genes = sobj@var.genes, 
               pcs.compute = 30, 
               do.print = F, 
               seed.use = 20180525)
PCElbowPlot(sobj, num.pc = 30)
sobj <- RunTSNE(sobj, dims.use = 1:25, seed.use = 20180525)

plt <- TSNEPlot(sobj)
save_plot("compare_to_baron_cotsne.pdf", plt)
```

####muraro dataset

try to co-cluster the datasets

```{r}
sc_mat <- assay(muraro_sce, "normcounts")
sc_mat <- as(sc_mat, "sparseMatrix")

rownames(sc_mat) <- str_split(rownames(sc_mat), "__", simplify = T)[, 1]

shared_genes <- intersect(rownames(bcells@data),
          rownames(sc_mat))
sc_mat <- sc_mat[shared_genes, ]
sc_mat <- log1p(sc_mat * 10)

combined_mat <- cbind(bcells@data[shared_genes, ],
                      sc_mat[shared_genes, ])

sobj <- CreateSeuratObject(combined_mat, 
                   min.cells = 5,
                   min.genes = 200)
rm(combined_mat)
rm(sc_mat)
#sobj <- NormalizeData(sobj)
sobj <- FindVariableGenes(sobj, do.plot = T, y.cutoff = 0.125)
sobj <- ScaleData(sobj, genes.use = sobj@var.genes, do.par = TRUE, num.cores = 4)
sobj <- RunPCA(sobj, pc.genes = sobj@var.genes, 
               pcs.compute = 30, 
               do.print = F, 
               seed.use = 20180525)
PCElbowPlot(sobj, num.pc = 30)
sobj <- RunTSNE(sobj, dims.use = 1:25, seed.use = 20180525)

plt <- TSNEPlot(sobj)
save_plot("compare_to_murano_cotsne.pdf", plt)
```

#### xin dataset

try to co-cluster the datasets

```{r}
sc_mat <- assay(xin_sce, "normcounts")
#rownames(sc_mat) <- rowData(xin_sce)$feature_symbol
sc_mat <- as(sc_mat, "sparseMatrix")

shared_genes <- intersect(rownames(bcells@data),
          rownames(sc_mat))

sc_mat <- sc_mat[shared_genes, ]
sc_mat <- log1p(sc_mat * 10)

combined_mat <- cbind(bcells@data[shared_genes, ],
                      sc_mat[shared_genes, ])

sobj <- CreateSeuratObject(combined_mat, 
                   min.cells = 5,
                   min.genes = 200)
rm(combined_mat)
rm(sc_mat)
#sobj <- NormalizeData(sobj)
sobj <- FindVariableGenes(sobj, do.plot = T, y.cutoff = 0.125)
sobj <- ScaleData(sobj, genes.use = sobj@var.genes, do.par = TRUE, num.cores = 4)
sobj <- RunPCA(sobj, pc.genes = sobj@var.genes, 
               pcs.compute = 30, 
               do.print = F, 
               seed.use = 20180525)
PCElbowPlot(sobj, num.pc = 30)
sobj <- RunTSNE(sobj, dims.use = 1:25, seed.use = 20180525)

plt <- TSNEPlot(sobj)
save_plot("compare_to_xin_cotsne.pdf", plt)
```

try to use alignment

```{r}
sc_mat <- assay(baron_sce, "counts")[shared_genes, ]
sc_mat <- as(sc_mat, "sparseMatrix")

# Set up control object
ctrl <- CreateSeuratObject(raw.data = bcells@raw.data, 
                           project = "iPSC", 
                           min.cells = 5)
ctrl@meta.data$type <- "iPSC"
ctrl <- FilterCells(ctrl, 
                    subset.names = "nGene", 
                    low.thresholds = 250, 
                    high.thresholds = Inf)
ctrl <- NormalizeData(ctrl)
ctrl <- FindVariableGenes(ctrl, do.plot = F,
                          x.low.cutoff = 0.1, 
                          x.high.cutoff = 5, 
                          y.cutoff = 0.4)
ctrl <- ScaleData(ctrl, genes.use = ctrl@var.genes, 
                  display.progress = F, do.par = T, num.cores = 4)

# Set up stimulated object
stim <- CreateSeuratObject(raw.data = sc_mat, 
                           project = "islet", 
                           min.cells = 5)
stim@meta.data$type <- "islet"
stim <- FilterCells(stim, 
                    subset.names = "nGene", 
                    low.thresholds = 250, 
                    high.thresholds = Inf)

stim <- NormalizeData(stim)
stim <- FindVariableGenes(stim, do.plot = F,
                          x.low.cutoff = 0.1, 
                          x.high.cutoff = 5, 
                          y.cutoff = 0.4)

stim <- ScaleData(stim, 
                  genes.use = stim@var.genes,
                  display.progress = F, do.par = T, num.cores = 4)

# Gene selection for input to CCA
genes.use <- unique(c(ctrl@var.genes, stim@var.genes))
genes.use <- intersect(genes.use, rownames(ctrl@scale.data))
genes.use <- intersect(genes.use, rownames(stim@scale.data))

panc_combined <- RunCCA(ctrl, stim, genes.use = genes.use, num.cc = 30)

p1 <- DimPlot(object = immune.combined, reduction.use = "cca", group.by = "stim", 
    pt.size = 0.5, do.return = TRUE)
p2 <- VlnPlot(object = immune.combined, features.plot = "CC1", group.by = "stim", 
    do.return = TRUE)
plot_grid(p1, p2)

p3 <- MetageneBicorPlot(immune.combined, grouping.var = "stim", dims.eval = 1:30, 
    display.progress = FALSE)

immune.combined <- AlignSubspace(immune.combined, reduction.type = "cca", grouping.var = "stim", 
    dims.align = 1:20)
```


```{r}
sobj <- readRDS("tmp.rds")
```



#### clustifyr approach

doesn't work very well
```{r eval = F}
ref_datasets <- lst(
  xin_sce,
  #seg_sce,
  muraro_sce
  #baron_sce
)

library(clustifyR)

mdata <- GetCellEmbeddings(bcells, reduction.type = "tsne")
mdata <- cbind(bcells@meta.data, mdata) %>% 
  tibble::rownames_to_column("cell")

ref_cluster_info <- map(ref_datasets,
                        function(x){
                          colData(x) %>% 
                            as.data.frame() %>%
                            tibble::rownames_to_column("cell")
                        })

ref_averages <- map2(ref_datasets, ref_cluster_info,
                    function(x, y){
                      average_clusters(normcounts(x),
                                       y,
                                       log_scale = F,
                                       cell_col = "cell",
                                       cluster_col = "cell_type1")
                    })


cor_res <- run_cor(bcells@data,
        mdata,
        log1p(ref_averages[[1]]),
        bcells@var.genes,
        cluster_col = "res.0.3",
        compute_method = corr_coef)

plts <- plot_cor(cor_res,
         mdata,
         cluster_col = "res.0.3")

plt <- plot_grid(plotlist = plts, nrow = 4, ncol = 3)

save_plot("compare_to_xin_et_al.pdf", plt, ncol = 3, nrow = 4)


weird_genenames <- rownames(ref_averages[[2]])
rownames(ref_averages[[2]]) <- str_split(weird_genenames, 
                                         "__", 
                                         simplify = T)[, 1]
cor_res <- run_cor(bcells@data,
        mdata,
        log1p(ref_averages[[2]]),
        bcells@var.genes,
        cluster_col = "res.0.3",
        compute_method = corr_coef)

plts <- plot_cor(cor_res,
         mdata,
         cluster_col = "res.0.3")

plt <- plot_grid(plotlist = plts, nrow = 4, ncol = 3)

save_plot("compare_to_muraro_et_al.pdf", plt, ncol = 3, nrow = 4)
```


```{r percell, eval = F}
cor_res <- run_cor(bcells@data,
        mdata,
        log1p(ref_averages[[1]]),
        bcells@var.genes,
        per_cell = T,
        cluster_col = "cell",
        compute_method = corr_coef)

plts <- plot_cor(cor_res,
         mdata,
         cluster_col = "cell")

plt <- plot_grid(plotlist = plts, nrow = 4, ncol = 3)

save_plot("compare_cells_to_xin_et_al.pdf", plt, ncol = 3, nrow = 4)

cor_res <- run_cor(bcells@data,
        mdata,
        log1p(ref_averages[[2]]),
        bcells@var.genes,
        per_cell = T,
        cluster_col = "cell",
        compute_method = corr_coef)

plts <- plot_cor(cor_res,
         mdata,
         cluster_col = "cell")

plt <- plot_grid(plotlist = plts, nrow = 4, ncol = 3)

save_plot("compare_cells_to_muraro_et_al.pdf", plt, ncol = 3, nrow = 4)
```


```{r}

tsne_coords <- GetCellEmbeddings(bcells, "tsne") %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column("cell")

meta_data <- bcells@meta.data %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column("cell")

meta_data_out <- inner_join(meta_data, tsne_coords, by = "cell")
write_tsv(meta_data_out, "metadata.tsv")
```
