---
title: "Holger Russ scRNA-Seq analysis"
author: "Kent Riemondy RBI"
date: "`R Sys.Date()`"
bibliography: ~/Projects/russ/docs/bibliography.bib 
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    fig_caption: yes
    fig_retina: 1 
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(cache.lazy = FALSE)
```


```{r libs, message=FALSE, warning=FALSE, echo=FALSE}
source("../../R/globals.R")
data_dir_expt1 <- "~/Projects/10x_data/runs/20180524_russ/results"
data_dir_expt2 <- "~/Projects/10x_data/runs/20180918_russ/results"
tcols <- rev(brewer.pal(11, "RdGy")[c(1:5, 7)])[1:6]
```

## Experiment Summary

Sample | Description
------------- | ---------------- 
Holger_CTRL | hPSC derived Beta cells 
Holger_T1D_modeling | hPSC derived Beta Cells exposed to diabetes related stress
Russ_GFP_Sort | 2nd experiment
Russ_d36GFP_Reagg | 2nd experiment

```{r get_data}

samples_expt1 <- c(
  "Holger_CTRL",
  "Holger_T1D_modeling")

sample_paths_1 <- file.path(data_dir_expt1,
                          samples_expt1,
                          "outs", 
                          "filtered_gene_bc_matrices", 
                          "GRCh38_transgenes")

names(sample_paths_1) <- samples_expt1

samples_expt2 <- c(
  "Russ_GFP_Sort",
  "Russ_d36GFP_Reagg")

sample_paths_2 <- file.path(data_dir_expt2,
                          samples_expt2,
                          "outs", 
                          "filtered_gene_bc_matrices", 
                          "GRCh38_transgenes")

names(sample_paths_2) <- samples_expt2

sample_paths <- c(sample_paths_1, sample_paths_2)
bcells <- map(sample_paths, Seurat::Read10X)
```

```{r create_seurat, message = F, results = 'hide', warning = F}
bcells <- map(bcells, ~CreateSeuratObject(raw.data = .x, 
                              min.cells = 5,
                              min.genes = 250, 
                              project = "Russ",
                              names.field = c(1,2), 
                              names.delim = "_"))
```

```{r additional_mdata}

# add correct sample identifier
ids <- imap(bcells, ~data.frame(row.names = rownmames(.x@meta.data), 
                                expt = rep(.y, nrow(.x@meta.data))))
bcells <- map2(bcells, ids, function(x, y) AddMetaData(x, y, "expt"))
```


## Mitochondrial Reads 

The percentage of reads aligning to mitochondria is often an indicator of cell quality. Cells that have lysed prior to capture preferentially retain mitochondial RNA, but lose cellular cytoplasmic mRNA. As shown below there is a strong negative correlation with the number of UMIs and the proportion of reads aligning to mitochondria. Cells with less than 20% mitochondrial reads will be retained for further analysis.

```{r QC}
mito.genes <- map(bcells, ~grep("^MT-", rownames(.x@data), value = T))
proportion.mito <- map2(bcells, mito.genes, ~Matrix::colSums(.x@data[.y, ]) /
  Matrix::colSums(.x@data))

bcells <- map2(bcells, proportion.mito, ~AddMetaData(.x, .y, "proportion.mito"))
```


```{r, apply_filters}
bcells <- map(bcells, ~FilterCells(.x, 
                       subset.names = c("nUMI", "proportion.mito"), 
                       low.thresholds = c(250, -Inf), 
                       high.thresholds = c(75000, 0.20)))
```

```{r normalize, results = 'hide'}
bcells <- map(bcells, NormalizeData)
bcells <- map(bcells, ScaleData, display.progress = F)
```

### Identify variable genes

  The normalized UMI count matrix contains `r  length(rownames(bcells@data))` genes and `r length(colnames(bcells@data))` cells. Most of these genes have very low expression or very low variance across all of the cells in the dataset. These genes are therefore very uninformative for classifying different cell types. In this next step the set of variable genes useful for classification will be identified, and used for downstream PCA, TSNE, and classification purposes. 
  
  Variable genes will be selected by examining a plot of the average expression across all cells on the x axis to the dispersion across all genes. Highly variable genes will have non-zero dispersion. The dispersion is defined by the variance / mean. 
  
```{r get_variable_genes, results = 'hide'}
bcells <- map(bcells, ~FindVariableGenes(.x, do.plot = F))

vargenes <- map(bcells, ~head(rownames(.x@hvg.info), 2000))

genes.use <- Reduce(function(x, y) intersect(x, y), vargenes)
```

## CCA

```{r cca}
bcell <- RunMultiCCA(bcells, genes.use = genes.use, add.cell.ids = names(bcells), num.cc = 30)
bcell <- AlignSubspace(bcell, reduction.type = "cca", grouping.var = "expt", 
    dims.align = 1:21)
bcell <- RunTSNE(bcell, reduction.use = "cca.aligned", dims.use = 1:20, 
    do.fast = T)


TSNEPlot(bcell, do.return = T, 
               pt.size = 0.5, group.by = "expt", 
         colors.use = viridis(4))

FeaturePlot(bcell, c("INS", "egfp"), do.return = T)

bcell <- FindClusters(bcell, 
                     reduction.type = "cca.aligned", 
                     dims.use = 1:21,
                     k.param = 40, 
                     resolution = 0.3, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, 
                     random.seed = 0)

saveRDS(bcell, "sobj_cca.rds")
bcell <- readRDS("sobj_cca.rds")
bcell <- SetAllIdent(bcell, "res.0.3")
if (!file.exists("res0.3_markers.txt")){
  bcells_markers <- FindAllMarkers(bcell, 
                                  only.pos = TRUE,  
                                  min.pct = 0.25, 
                                  logfc.threshold = 0.5)
  
  write_tsv(bcells_markers, "res0.3_markers.txt")
} else {
  bcells_markers <- read_tsv("res0.3_markers.txt")
}

bcells_markers %>% 
  group_by(cluster) %>% 
  top_n(25, avg_logFC) -> top25

```

### Control for noise
  Single-cell data is often noisy, and it is difficult to compare cells with very high UMIs to very low UMIs. For classification we do not want to bias our clusters based on nuisance variables such as UMI count or proportion of mitochondria. To help mitigate bias in our clustering a regression model is fit to predict gene expression based on nuisance variables. The residuals from this fit are then scaled and centered (i.e. turned into z-scores) for classification purposes. The scaled regressed data is not used for differential expression, but used only for classifcation, TSNE visualization, and pseudotime analysis. 

```{r scale_data, results='hide', message = F}
bcells <- ScaleData(bcells, 
                    genes.use = bcells@var.genes, 
                    vars.to.regress = c("nUMI","proportion.mito"))
```

### Calculate Principal Components

  PCA will now be performed on processed data using only the set of variable genes defined above. PCA will generate a set of new vectors that describe the variablity in the data. A subset of these principal components will be selected to be used as input data for TSNE visualization. Selecting the proper number of components is informed by examining the amount of variance captured in each PC. Shown below is a plot of variance captured in each PC. At a certain point, additional PCs capture little additional varaince, and therefore are uninformative for classification. For this dataset 17 PCs will be used for classification.
  
```{r PCA_calc, results='hide'}
bcells <- RunPCA(bcells, 
               pc.genes = bcells@var.genes, 
               do.print = FALSE, 
               pcs.print = 1:5, 
               genes.print = 5,
               seed.use = 20180530)

PCElbowPlot(bcells)
```

### PCA Plots {.tabset .tabsetfade}
  Shown in the tabs are 2 dimensional plots showing different principal components. Overall the data looks good as there is quite alot of structure to the data and many consisent populations that match the sample types are observed.
  
```{r pc_plots, results ='asis'}
pcs <- list(
  c(1, 2),
  c(1, 3),
  c(1, 4),
  c(2, 3),
  c(2, 4),
  c(3, 4)
)


for(i in seq_along(pcs)){
  cat('\n#### ', 'PC', pcs[[i]][1], ' vs PC', pcs[[i]][2], '\n', sep = "")
  PCAPlot(bcells, 
               pcs[[i]][1], 
               pcs[[i]][2], 
               cols.use = brewer.pal(10, "Paired"), 
        group.by = "expt")
  #print(p)
  cat('\n')
}
```

### Run TSNE {.tabset .tabsetfade}
    
#### Sample Names

```{r plot_TSNE, fig.width = 10, fig.height = 10}
TSNEPlot(bcell, 
         colors.use = brewer.pal(n = 10, 
                                 "Paired"), 
         group.by = "expt")
```


#### Genes Detected
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcell, "nGene", no.legend = F)
```

#### UMIs Detected
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcell, "nUMI", no.legend = F)
```

#### Proportion Mito
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcell, "proportion.mito", no.legend = F)

```

#### eGFP
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcell, "egfp", no.legend = F)
```


#### firefly-luc
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(bcells, "luc-firefly", no.legend = F)
```

#### Per expt
```{r, fig.width = 16, fig.height= 4}
bcells <- SetAllIdent(bcells, "expt")
sample_names <- unique(bcells@meta.data$expt)
ord <- levels(bcells@meta.data$expt)

cell_ids <- map(ord, ~bcells@cell.names[bcells@meta.data$expt == .x])
names(cell_ids) <- ord
.cols <- brewer.pal(n = 10, "Paired")[1:length(sample_names)]

p <- map2(cell_ids,
         .cols,
         ~TSNEPlot(bcells, 
                   do.label = F, 
                   pt.size = 0.5, 
                   cells.use = .x, 
                   do.return = T, 
                   colors.use = .y,
                   label.size = 5))

p[[5]] <- TSNEPlot(bcells, 
                   do.label = F, 
                   pt.size = 0.5, 
                   do.return = T, 
                   colors.use  = .cols,
                   label.size = 5)


plt <- plot_grid(plotlist = p, nrow = 1, 
                 align = "hv")

plt
```

## Cluster identification {.tabset}

  Unsupervised clustering was next performed to identify transcriptionally distinct cell populations. A graph-based algorithm was used that builds a k-nearest neighbor (KNN) graph on the euclidean distances calculated from principal components, weights each edge based on the local neighborhood using jaccard statistics, then prunes the graph to select clusters using an optimization function. The graph based algorithm is implemented in the Seurat R package.  Clusters are visualized using TSNE, but the cluster assignments are based on the first 15 principal components.


```{r find_clusters, fig.width = 14, fig.height = 10, warning=FALSE}
bcells <- FindClusters(bcells, 
                     reduction.type = "pca", 
                     dims.use = 1:17,
                     k.param = 40, 
                     resolution = 0.3, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, 
                     random.seed = 0)

bcells <- FindClusters(bcells, 
                     reduction.type = "pca", 
                     dims.use =1:17,
                     k.param = 40, 
                     resolution = 0.5, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, 
                     random.seed = 0)

bcells <- FindClusters(bcells, 
                     reduction.type = "pca", 
                     dims.use = 1:17, 
                     k.param  = 30, 
                     resolution = 0.8, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, 
                     random.seed = 0)

bcells <- FindClusters(bcells, 
                     reduction.type = "pca", 
                     dims.use =1:17, 
                     k.param  = 30, 
                     resolution = 1.0, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, 
                     random.seed = 0)

bcells <- FindClusters(bcells, 
                     reduction.type = "pca", 
                     dims.use = 1:17, 
                     k.param = 30, 
                     resolution = 1.1, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, 
                     random.seed = 0)

bcells <- FindClusters(bcells, 
                     reduction.type = "pca", 
                     dims.use = 1:17, 
                     k.param = 30, 
                     resolution = 1.2, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, 
                     random.seed = 0)

bcells <- FindClusters(bcells, 
                     reduction.type = "pca", 
                     dims.use = 1:17, 
                     k.param = 30, 
                     resolution = 1.5, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, 
                     random.seed = 0)

clustering_params <- colnames(bcells@meta.data) %>% 
  str_subset("res")

# generate tsnes for each clustering setting
clust_tsnes <- map(clustering_params,
     function(x){
       bcells <- SetAllIdent(bcells, x); 
       TSNEPlot(bcells, 
                pt.size = 0.5,
                do.label = T,
                label.size = 10,
                do.return = T,
                no.legend = T, 
                plot.title = x)
     })


plot_grid(plotlist = clust_tsnes)
```


## Marker gene expression for each cluster {.tabset .tabset-fade}

  Plotted below are a set of known marker genes that help to identify each cell population. 

Click on the tabs to view other markers

```{r marker genes, fig.width = 10, fig.height= 10}

control_markers <- c(
  "CD9",
  "ST8SIA1",
  "INS",
  "NPY",
  "KCNE4",
  "HCN1",
  "DAB1",
  "ST8SIA1",
  "HCN4",
  "NEUROD1",
  "SCGB2A1",
  "KLHL1",
  "SLC44A4"
)
```

### Various
```{r, fig.width=10, fig.height=20}
FeaturePlot(bcells, control_markers, 
            pt.size = 0.50, cols.use = tcols)

```


## Gene expression per cluster

Next we will determine genes enriched in each sample by comparing gene expression in each sample to all other samples. Plotted below are the top 10 enriched genes detected in each sample for all cell transcriptomes (Yellow is high, purple is low).

```{r find_markers}
bcells <- SetAllIdent(bcells, "res.0.3")
if (!file.exists("res0.3_markers.txt")){
  bcells_markers <- FindAllMarkers(bcells, 
                                  only.pos = TRUE,  
                                  min.pct = 0.25, 
                                  thresh.use = 0.25)
  
  write_tsv(bcells_markers, "res0.3_markers.txt")
} else {
  bcells_markers <- read_tsv("res0.3_markers.txt")
}

bcells_markers %>% 
  group_by(cluster) %>% 
  top_n(25, avg_logFC) -> top25

```

```{r, fig.width = 20, fig.height= 20}
pdf("marker_heatmap.pdf", width = 12, height = 8)
DoHeatmap(bcell, 
          genes.use = top25$gene, 
          slim.col.label = TRUE, 
          cex.row = 1, 
          remove.key = TRUE)
dev.off()
```


## Top genes per cell type {.tabset .tabset-fade}
  Plotted are the abundances of the top marker genes detected per identified cell type (red is high, yellow is low) projected onto the TSNE map. 
  
```{r genes_enriched_per_cluster}
top_genenames <- split(top25, 
                        top25$cluster) %>% 
  map(., ~.x[1:4, ]$gene)

```

```{r tsnes_per_cluster, fig.width = 10, fig.height= 10, results = "asis"}

for(i in seq_along(top_genenames)){
  cat('\n### ', names(top_genenames)[i], '\n', sep = "")
  FeaturePlot(bcells, top_genenames[[i]], pt.size = 0.5, cols.use = tcols)
  cat('\n')
}
```


## Distribution of cells per cell type

. 
```{r cluster_distribution}
cluster_ids <- bcells@meta.data$res.0.3
cell_ids <- bcells@cell.names
expt <- bcells@meta.data$expt

cluster_summary <- data_frame(id = cell_ids, expt = expt, cluster = cluster_ids)
cluster_summary <- group_by(cluster_summary, expt, cluster) %>% summarize(cells = n())

ggplot(cluster_summary, aes(cluster, cells)) +
  ylab("Number of Cells") +
  scale_fill_brewer(palette = "Paired") +
  geom_bar(stat = "identity", 
           aes(fill = expt), position = "dodge") 
  
```

```{r save}
saveRDS(bcells, file = "sobj.rds")
```

### xcel spreadsheet

```{r}
markers <- read_tsv("res0.3_markers.txt")

list_of_markers <- split(markers, markers$cluster)
names(list_of_markers) <- str_c("cluster_", names(list_of_markers))
list_of_markers <- map(list_of_markers, 
                       ~set_xlsx_class(.x, "gene", "Text"))

readme_sheet <- data_frame(
  Columns = c(
  "Genes differentially expressed between each cluster and all other cells",
  "",
  "Columns",
  "pval",
  "avg_logFC",
  "pct.1",
  "pct.2",
  "p_val_adj",
  "cluster",
  "gene"
), Description = c(
  "",
  "",
  "",
  "p-value from wilcox test of indicated cluster compared to other clusters",
  "average fold change expressed in natural log",
  "percent of cells expressing gene (UMI > 0) in cluster",
  "percent of cell expressing gene (UMI > 0) in all other clusters",
  "Bonferroni corrected p-value",
  "cluster name",
  "gene name"
))

readme_sheet <- list(README = readme_sheet)
names(readme_sheet) <- "README"

openxlsx::write.xlsx(c(readme_sheet, 
                       list_of_markers),
                     "markers_per_cluster.xlsx")
```
## Session Info
```{r ses}
sessionInfo()
```